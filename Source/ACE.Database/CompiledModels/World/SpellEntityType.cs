// <auto-generated />
using System;
using System.Reflection;
using ACE.Database.Models.World;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage;
using Pomelo.EntityFrameworkCore.MySql.Storage.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace ACE.Database.CompiledModels.World
{
    internal partial class SpellEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "ACE.Database.Models.World.Spell",
                typeof(Spell),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(uint),
                propertyInfo: typeof(Spell).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0u);
            id.TypeMapping = MySqlUIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                providerValueComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v));
            id.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            id.AddAnnotation("Relational:ColumnName", "id");

            var align = runtimeEntityType.AddProperty(
                "Align",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("Align", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<Align>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            align.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            align.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            align.AddAnnotation("Relational:ColumnName", "align");

            var baseIntensity = runtimeEntityType.AddProperty(
                "BaseIntensity",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("BaseIntensity", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<BaseIntensity>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            baseIntensity.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            baseIntensity.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            baseIntensity.AddAnnotation("Relational:ColumnName", "base_Intensity");

            var boost = runtimeEntityType.AddProperty(
                "Boost",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("Boost", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<Boost>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            boost.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            boost.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            boost.AddAnnotation("Relational:ColumnName", "boost");

            var boostVariance = runtimeEntityType.AddProperty(
                "BoostVariance",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("BoostVariance", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<BoostVariance>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            boostVariance.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            boostVariance.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            boostVariance.AddAnnotation("Relational:ColumnName", "boost_Variance");

            var createOffsetOriginX = runtimeEntityType.AddProperty(
                "CreateOffsetOriginX",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("CreateOffsetOriginX", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<CreateOffsetOriginX>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            createOffsetOriginX.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            createOffsetOriginX.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            createOffsetOriginX.AddAnnotation("Relational:ColumnName", "create_Offset_Origin_X");

            var createOffsetOriginY = runtimeEntityType.AddProperty(
                "CreateOffsetOriginY",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("CreateOffsetOriginY", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<CreateOffsetOriginY>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            createOffsetOriginY.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            createOffsetOriginY.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            createOffsetOriginY.AddAnnotation("Relational:ColumnName", "create_Offset_Origin_Y");

            var createOffsetOriginZ = runtimeEntityType.AddProperty(
                "CreateOffsetOriginZ",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("CreateOffsetOriginZ", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<CreateOffsetOriginZ>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            createOffsetOriginZ.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            createOffsetOriginZ.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            createOffsetOriginZ.AddAnnotation("Relational:ColumnName", "create_Offset_Origin_Z");

            var critFreq = runtimeEntityType.AddProperty(
                "CritFreq",
                typeof(double?),
                propertyInfo: typeof(Spell).GetProperty("CritFreq", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<CritFreq>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            critFreq.TypeMapping = MySqlDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                keyComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                providerValueComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)));
            critFreq.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            critFreq.AddAnnotation("Relational:ColumnName", "crit_Freq");

            var critMultiplier = runtimeEntityType.AddProperty(
                "CritMultiplier",
                typeof(double?),
                propertyInfo: typeof(Spell).GetProperty("CritMultiplier", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<CritMultiplier>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            critMultiplier.TypeMapping = MySqlDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                keyComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                providerValueComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)));
            critMultiplier.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            critMultiplier.AddAnnotation("Relational:ColumnName", "crit_Multiplier");

            var damageRatio = runtimeEntityType.AddProperty(
                "DamageRatio",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("DamageRatio", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<DamageRatio>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            damageRatio.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            damageRatio.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            damageRatio.AddAnnotation("Relational:ColumnName", "damage_Ratio");

            var damageType = runtimeEntityType.AddProperty(
                "DamageType",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("DamageType", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<DamageType>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            damageType.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            damageType.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            damageType.AddAnnotation("Relational:ColumnName", "damage_Type");

            var defaultLaunchAngle = runtimeEntityType.AddProperty(
                "DefaultLaunchAngle",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("DefaultLaunchAngle", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<DefaultLaunchAngle>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            defaultLaunchAngle.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            defaultLaunchAngle.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            defaultLaunchAngle.AddAnnotation("Relational:ColumnName", "default_Launch_Angle");

            var destination = runtimeEntityType.AddProperty(
                "Destination",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("Destination", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<Destination>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            destination.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            destination.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            destination.AddAnnotation("Relational:ColumnName", "destination");

            var dimsOriginX = runtimeEntityType.AddProperty(
                "DimsOriginX",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("DimsOriginX", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<DimsOriginX>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            dimsOriginX.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            dimsOriginX.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            dimsOriginX.AddAnnotation("Relational:ColumnName", "dims_Origin_X");

            var dimsOriginY = runtimeEntityType.AddProperty(
                "DimsOriginY",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("DimsOriginY", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<DimsOriginY>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            dimsOriginY.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            dimsOriginY.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            dimsOriginY.AddAnnotation("Relational:ColumnName", "dims_Origin_Y");

            var dimsOriginZ = runtimeEntityType.AddProperty(
                "DimsOriginZ",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("DimsOriginZ", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<DimsOriginZ>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            dimsOriginZ.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            dimsOriginZ.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            dimsOriginZ.AddAnnotation("Relational:ColumnName", "dims_Origin_Z");

            var dispelSchool = runtimeEntityType.AddProperty(
                "DispelSchool",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("DispelSchool", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<DispelSchool>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            dispelSchool.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            dispelSchool.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            dispelSchool.AddAnnotation("Relational:ColumnName", "dispel_School");

            var dotDuration = runtimeEntityType.AddProperty(
                "DotDuration",
                typeof(double?),
                propertyInfo: typeof(Spell).GetProperty("DotDuration", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<DotDuration>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            dotDuration.TypeMapping = MySqlDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                keyComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                providerValueComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)));
            dotDuration.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            dotDuration.AddAnnotation("Relational:ColumnName", "dot_Duration");

            var drainPercentage = runtimeEntityType.AddProperty(
                "DrainPercentage",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("DrainPercentage", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<DrainPercentage>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            drainPercentage.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            drainPercentage.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            drainPercentage.AddAnnotation("Relational:ColumnName", "drain_Percentage");

            var eType = runtimeEntityType.AddProperty(
                "EType",
                typeof(uint?),
                propertyInfo: typeof(Spell).GetProperty("EType", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<EType>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            eType.TypeMapping = MySqlUIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                keyComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                providerValueComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)));
            eType.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            eType.AddAnnotation("Relational:ColumnName", "e_Type");

            var elementalModifier = runtimeEntityType.AddProperty(
                "ElementalModifier",
                typeof(double?),
                propertyInfo: typeof(Spell).GetProperty("ElementalModifier", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<ElementalModifier>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            elementalModifier.TypeMapping = MySqlDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                keyComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                providerValueComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)));
            elementalModifier.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            elementalModifier.AddAnnotation("Relational:ColumnName", "elemental_Modifier");

            var ignoreMagicResist = runtimeEntityType.AddProperty(
                "IgnoreMagicResist",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("IgnoreMagicResist", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<IgnoreMagicResist>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            ignoreMagicResist.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            ignoreMagicResist.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            ignoreMagicResist.AddAnnotation("Relational:ColumnName", "ignore_Magic_Resist");

            var imbuedEffect = runtimeEntityType.AddProperty(
                "ImbuedEffect",
                typeof(uint?),
                propertyInfo: typeof(Spell).GetProperty("ImbuedEffect", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<ImbuedEffect>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            imbuedEffect.TypeMapping = MySqlUIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                keyComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                providerValueComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)));
            imbuedEffect.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            imbuedEffect.AddAnnotation("Relational:ColumnName", "imbued_Effect");

            var index = runtimeEntityType.AddProperty(
                "Index",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("Index", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<Index>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            index.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            index.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            index.AddAnnotation("Relational:ColumnName", "index");

            var lastModified = runtimeEntityType.AddProperty(
                "LastModified",
                typeof(DateTime),
                propertyInfo: typeof(Spell).GetProperty("LastModified", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<LastModified>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAddOrUpdate,
                beforeSaveBehavior: PropertySaveBehavior.Ignore,
                afterSaveBehavior: PropertySaveBehavior.Ignore,
                sentinel: new DateTime(1, 1, 1, 0, 0, 0, 0, DateTimeKind.Unspecified));
            lastModified.TypeMapping = MySqlDateTimeTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                keyComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v),
                providerValueComparer: new ValueComparer<DateTime>(
                    (DateTime v1, DateTime v2) => v1.Equals(v2),
                    (DateTime v) => v.GetHashCode(),
                    (DateTime v) => v));
            lastModified.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.ComputedColumn);
            lastModified.AddAnnotation("Relational:ColumnName", "last_Modified");
            lastModified.AddAnnotation("Relational:ColumnType", "datetime");
            lastModified.AddAnnotation("Relational:DefaultValueSql", "CURRENT_TIMESTAMP");

            var link = runtimeEntityType.AddProperty(
                "Link",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("Link", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<Link>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            link.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            link.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            link.AddAnnotation("Relational:ColumnName", "link");

            var lossPercent = runtimeEntityType.AddProperty(
                "LossPercent",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("LossPercent", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<LossPercent>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            lossPercent.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            lossPercent.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            lossPercent.AddAnnotation("Relational:ColumnName", "loss_Percent");

            var maxBoostAllowed = runtimeEntityType.AddProperty(
                "MaxBoostAllowed",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("MaxBoostAllowed", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<MaxBoostAllowed>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            maxBoostAllowed.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            maxBoostAllowed.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            maxBoostAllowed.AddAnnotation("Relational:ColumnName", "max_Boost_Allowed");

            var maxPower = runtimeEntityType.AddProperty(
                "MaxPower",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("MaxPower", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<MaxPower>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            maxPower.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            maxPower.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            maxPower.AddAnnotation("Relational:ColumnName", "max_Power");

            var minPower = runtimeEntityType.AddProperty(
                "MinPower",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("MinPower", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<MinPower>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            minPower.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            minPower.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            minPower.AddAnnotation("Relational:ColumnName", "min_Power");

            var name = runtimeEntityType.AddProperty(
                "Name",
                typeof(string),
                propertyInfo: typeof(Spell).GetProperty("Name", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<Name>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            name.TypeMapping = MySqlStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "text"),
                storeTypePostfix: StoreTypePostfix.None);
            name.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            name.AddAnnotation("Relational:ColumnName", "name");
            name.AddAnnotation("Relational:ColumnType", "text");

            var nonTracking = runtimeEntityType.AddProperty(
                "NonTracking",
                typeof(bool?),
                propertyInfo: typeof(Spell).GetProperty("NonTracking", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<NonTracking>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            nonTracking.TypeMapping = MySqlBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                keyComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                providerValueComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "bit(1)"));
            nonTracking.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            nonTracking.AddAnnotation("Relational:ColumnName", "non_Tracking");

            var numProjectiles = runtimeEntityType.AddProperty(
                "NumProjectiles",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("NumProjectiles", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<NumProjectiles>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            numProjectiles.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            numProjectiles.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            numProjectiles.AddAnnotation("Relational:ColumnName", "num_Projectiles");

            var numProjectilesVariance = runtimeEntityType.AddProperty(
                "NumProjectilesVariance",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("NumProjectilesVariance", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<NumProjectilesVariance>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            numProjectilesVariance.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            numProjectilesVariance.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            numProjectilesVariance.AddAnnotation("Relational:ColumnName", "num_Projectiles_Variance");

            var number = runtimeEntityType.AddProperty(
                "Number",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("Number", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<Number>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            number.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            number.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            number.AddAnnotation("Relational:ColumnName", "number");

            var numberVariance = runtimeEntityType.AddProperty(
                "NumberVariance",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("NumberVariance", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<NumberVariance>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            numberVariance.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            numberVariance.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            numberVariance.AddAnnotation("Relational:ColumnName", "number_Variance");

            var paddingOriginX = runtimeEntityType.AddProperty(
                "PaddingOriginX",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("PaddingOriginX", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<PaddingOriginX>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            paddingOriginX.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            paddingOriginX.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            paddingOriginX.AddAnnotation("Relational:ColumnName", "padding_Origin_X");

            var paddingOriginY = runtimeEntityType.AddProperty(
                "PaddingOriginY",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("PaddingOriginY", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<PaddingOriginY>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            paddingOriginY.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            paddingOriginY.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            paddingOriginY.AddAnnotation("Relational:ColumnName", "padding_Origin_Y");

            var paddingOriginZ = runtimeEntityType.AddProperty(
                "PaddingOriginZ",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("PaddingOriginZ", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<PaddingOriginZ>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            paddingOriginZ.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            paddingOriginZ.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            paddingOriginZ.AddAnnotation("Relational:ColumnName", "padding_Origin_Z");

            var peturbationOriginX = runtimeEntityType.AddProperty(
                "PeturbationOriginX",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("PeturbationOriginX", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<PeturbationOriginX>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            peturbationOriginX.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            peturbationOriginX.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            peturbationOriginX.AddAnnotation("Relational:ColumnName", "peturbation_Origin_X");

            var peturbationOriginY = runtimeEntityType.AddProperty(
                "PeturbationOriginY",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("PeturbationOriginY", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<PeturbationOriginY>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            peturbationOriginY.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            peturbationOriginY.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            peturbationOriginY.AddAnnotation("Relational:ColumnName", "peturbation_Origin_Y");

            var peturbationOriginZ = runtimeEntityType.AddProperty(
                "PeturbationOriginZ",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("PeturbationOriginZ", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<PeturbationOriginZ>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            peturbationOriginZ.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            peturbationOriginZ.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            peturbationOriginZ.AddAnnotation("Relational:ColumnName", "peturbation_Origin_Z");

            var positionAnglesW = runtimeEntityType.AddProperty(
                "PositionAnglesW",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("PositionAnglesW", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<PositionAnglesW>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            positionAnglesW.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            positionAnglesW.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            positionAnglesW.AddAnnotation("Relational:ColumnName", "position_Angles_W");

            var positionAnglesX = runtimeEntityType.AddProperty(
                "PositionAnglesX",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("PositionAnglesX", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<PositionAnglesX>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            positionAnglesX.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            positionAnglesX.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            positionAnglesX.AddAnnotation("Relational:ColumnName", "position_Angles_X");

            var positionAnglesY = runtimeEntityType.AddProperty(
                "PositionAnglesY",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("PositionAnglesY", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<PositionAnglesY>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            positionAnglesY.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            positionAnglesY.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            positionAnglesY.AddAnnotation("Relational:ColumnName", "position_Angles_Y");

            var positionAnglesZ = runtimeEntityType.AddProperty(
                "PositionAnglesZ",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("PositionAnglesZ", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<PositionAnglesZ>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            positionAnglesZ.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            positionAnglesZ.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            positionAnglesZ.AddAnnotation("Relational:ColumnName", "position_Angles_Z");

            var positionObjCellId = runtimeEntityType.AddProperty(
                "PositionObjCellId",
                typeof(uint?),
                propertyInfo: typeof(Spell).GetProperty("PositionObjCellId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<PositionObjCellId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            positionObjCellId.TypeMapping = MySqlUIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                keyComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                providerValueComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)));
            positionObjCellId.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            positionObjCellId.AddAnnotation("Relational:ColumnName", "position_Obj_Cell_ID");

            var positionOriginX = runtimeEntityType.AddProperty(
                "PositionOriginX",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("PositionOriginX", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<PositionOriginX>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            positionOriginX.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            positionOriginX.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            positionOriginX.AddAnnotation("Relational:ColumnName", "position_Origin_X");

            var positionOriginY = runtimeEntityType.AddProperty(
                "PositionOriginY",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("PositionOriginY", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<PositionOriginY>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            positionOriginY.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            positionOriginY.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            positionOriginY.AddAnnotation("Relational:ColumnName", "position_Origin_Y");

            var positionOriginZ = runtimeEntityType.AddProperty(
                "PositionOriginZ",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("PositionOriginZ", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<PositionOriginZ>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            positionOriginZ.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            positionOriginZ.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            positionOriginZ.AddAnnotation("Relational:ColumnName", "position_Origin_Z");

            var powerVariance = runtimeEntityType.AddProperty(
                "PowerVariance",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("PowerVariance", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<PowerVariance>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            powerVariance.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            powerVariance.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            powerVariance.AddAnnotation("Relational:ColumnName", "power_Variance");

            var proportion = runtimeEntityType.AddProperty(
                "Proportion",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("Proportion", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<Proportion>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            proportion.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            proportion.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            proportion.AddAnnotation("Relational:ColumnName", "proportion");

            var slayerCreatureType = runtimeEntityType.AddProperty(
                "SlayerCreatureType",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("SlayerCreatureType", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<SlayerCreatureType>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            slayerCreatureType.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            slayerCreatureType.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            slayerCreatureType.AddAnnotation("Relational:ColumnName", "slayer_Creature_Type");

            var slayerDamageBonus = runtimeEntityType.AddProperty(
                "SlayerDamageBonus",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("SlayerDamageBonus", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<SlayerDamageBonus>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            slayerDamageBonus.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            slayerDamageBonus.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            slayerDamageBonus.AddAnnotation("Relational:ColumnName", "slayer_Damage_Bonus");

            var source = runtimeEntityType.AddProperty(
                "Source",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("Source", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<Source>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            source.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            source.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            source.AddAnnotation("Relational:ColumnName", "source");

            var sourceLoss = runtimeEntityType.AddProperty(
                "SourceLoss",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("SourceLoss", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<SourceLoss>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            sourceLoss.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            sourceLoss.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            sourceLoss.AddAnnotation("Relational:ColumnName", "source_Loss");

            var spreadAngle = runtimeEntityType.AddProperty(
                "SpreadAngle",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("SpreadAngle", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<SpreadAngle>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            spreadAngle.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            spreadAngle.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            spreadAngle.AddAnnotation("Relational:ColumnName", "spread_Angle");

            var statModKey = runtimeEntityType.AddProperty(
                "StatModKey",
                typeof(uint?),
                propertyInfo: typeof(Spell).GetProperty("StatModKey", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<StatModKey>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            statModKey.TypeMapping = MySqlUIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                keyComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                providerValueComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)));
            statModKey.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            statModKey.AddAnnotation("Relational:ColumnName", "stat_Mod_Key");

            var statModType = runtimeEntityType.AddProperty(
                "StatModType",
                typeof(uint?),
                propertyInfo: typeof(Spell).GetProperty("StatModType", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<StatModType>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            statModType.TypeMapping = MySqlUIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                keyComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                providerValueComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)));
            statModType.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            statModType.AddAnnotation("Relational:ColumnName", "stat_Mod_Type");

            var statModVal = runtimeEntityType.AddProperty(
                "StatModVal",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("StatModVal", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<StatModVal>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            statModVal.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            statModVal.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            statModVal.AddAnnotation("Relational:ColumnName", "stat_Mod_Val");

            var transferBitfield = runtimeEntityType.AddProperty(
                "TransferBitfield",
                typeof(uint?),
                propertyInfo: typeof(Spell).GetProperty("TransferBitfield", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<TransferBitfield>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            transferBitfield.TypeMapping = MySqlUIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                keyComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                providerValueComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)));
            transferBitfield.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            transferBitfield.AddAnnotation("Relational:ColumnName", "transfer_Bitfield");

            var transferCap = runtimeEntityType.AddProperty(
                "TransferCap",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("TransferCap", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<TransferCap>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            transferCap.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            transferCap.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            transferCap.AddAnnotation("Relational:ColumnName", "transfer_Cap");

            var variance = runtimeEntityType.AddProperty(
                "Variance",
                typeof(int?),
                propertyInfo: typeof(Spell).GetProperty("Variance", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<Variance>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            variance.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            variance.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            variance.AddAnnotation("Relational:ColumnName", "variance");

            var verticalAngle = runtimeEntityType.AddProperty(
                "VerticalAngle",
                typeof(float?),
                propertyInfo: typeof(Spell).GetProperty("VerticalAngle", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<VerticalAngle>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            verticalAngle.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            verticalAngle.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            verticalAngle.AddAnnotation("Relational:ColumnName", "vertical_Angle");

            var wcid = runtimeEntityType.AddProperty(
                "Wcid",
                typeof(uint?),
                propertyInfo: typeof(Spell).GetProperty("Wcid", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Spell).GetField("<Wcid>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            wcid.TypeMapping = MySqlUIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                keyComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                providerValueComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)));
            wcid.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            wcid.AddAnnotation("Relational:ColumnName", "wcid");

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "spell");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
