// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using ACE.Database.Models.World;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage;
using Pomelo.EntityFrameworkCore.MySql.Storage.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace ACE.Database.CompiledModels.World
{
    internal partial class WeeniePropertiesEmoteActionEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "ACE.Database.Models.World.WeeniePropertiesEmoteAction",
                typeof(WeeniePropertiesEmoteAction),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(uint),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0u);
            id.TypeMapping = MySqlUIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                providerValueComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v));
            id.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.IdentityColumn);
            id.AddAnnotation("Relational:ColumnName", "id");

            var amount = runtimeEntityType.AddProperty(
                "Amount",
                typeof(int?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Amount", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Amount>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            amount.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            amount.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            amount.AddAnnotation("Relational:ColumnName", "amount");

            var amount64 = runtimeEntityType.AddProperty(
                "Amount64",
                typeof(long?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Amount64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Amount64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            amount64.TypeMapping = MySqlLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
            amount64.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            amount64.AddAnnotation("Relational:ColumnName", "amount_64");

            var anglesW = runtimeEntityType.AddProperty(
                "AnglesW",
                typeof(float?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("AnglesW", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<AnglesW>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            anglesW.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            anglesW.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            anglesW.AddAnnotation("Relational:ColumnName", "angles_W");

            var anglesX = runtimeEntityType.AddProperty(
                "AnglesX",
                typeof(float?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("AnglesX", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<AnglesX>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            anglesX.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            anglesX.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            anglesX.AddAnnotation("Relational:ColumnName", "angles_X");

            var anglesY = runtimeEntityType.AddProperty(
                "AnglesY",
                typeof(float?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("AnglesY", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<AnglesY>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            anglesY.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            anglesY.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            anglesY.AddAnnotation("Relational:ColumnName", "angles_Y");

            var anglesZ = runtimeEntityType.AddProperty(
                "AnglesZ",
                typeof(float?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("AnglesZ", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<AnglesZ>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            anglesZ.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            anglesZ.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            anglesZ.AddAnnotation("Relational:ColumnName", "angles_Z");

            var delay = runtimeEntityType.AddProperty(
                "Delay",
                typeof(float),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Delay", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Delay>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                sentinel: 0f);
            delay.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                keyComparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                providerValueComparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v));
            delay.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            delay.AddAnnotation("Relational:ColumnName", "delay");
            delay.AddAnnotation("Relational:DefaultValueSql", "'1'");

            var destinationType = runtimeEntityType.AddProperty(
                "DestinationType",
                typeof(sbyte?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("DestinationType", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<DestinationType>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            destinationType.TypeMapping = MySqlSByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>)),
                keyComparer: new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>)),
                providerValueComparer: new ValueComparer<sbyte?>(
                    (Nullable<sbyte> v1, Nullable<sbyte> v2) => v1.HasValue && v2.HasValue && (sbyte)v1 == (sbyte)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<sbyte> v) => v.HasValue ? (int)(sbyte)v : 0,
                    (Nullable<sbyte> v) => v.HasValue ? (Nullable<sbyte>)(sbyte)v : default(Nullable<sbyte>)));
            destinationType.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            destinationType.AddAnnotation("Relational:ColumnName", "destination_Type");

            var display = runtimeEntityType.AddProperty(
                "Display",
                typeof(bool?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Display", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Display>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            display.TypeMapping = MySqlBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                keyComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                providerValueComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "bit(1)"));
            display.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            display.AddAnnotation("Relational:ColumnName", "display");

            var emoteId = runtimeEntityType.AddProperty(
                "EmoteId",
                typeof(uint),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("EmoteId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<EmoteId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0u);
            emoteId.TypeMapping = MySqlUIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                providerValueComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v));
            emoteId.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            emoteId.AddAnnotation("Relational:ColumnName", "emote_Id");

            var extent = runtimeEntityType.AddProperty(
                "Extent",
                typeof(float),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Extent", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Extent>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                sentinel: 0f);
            extent.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                keyComparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v),
                providerValueComparer: new ValueComparer<float>(
                    (float v1, float v2) => v1.Equals(v2),
                    (float v) => v.GetHashCode(),
                    (float v) => v));
            extent.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            extent.AddAnnotation("Relational:ColumnName", "extent");
            extent.AddAnnotation("Relational:DefaultValueSql", "'1'");

            var heroXP64 = runtimeEntityType.AddProperty(
                "HeroXP64",
                typeof(long?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("HeroXP64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<HeroXP64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            heroXP64.TypeMapping = MySqlLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
            heroXP64.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            heroXP64.AddAnnotation("Relational:ColumnName", "hero_X_P_64");

            var max = runtimeEntityType.AddProperty(
                "Max",
                typeof(int?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Max", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Max>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            max.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            max.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            max.AddAnnotation("Relational:ColumnName", "max");

            var max64 = runtimeEntityType.AddProperty(
                "Max64",
                typeof(long?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Max64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Max64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            max64.TypeMapping = MySqlLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
            max64.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            max64.AddAnnotation("Relational:ColumnName", "max_64");

            var maxDbl = runtimeEntityType.AddProperty(
                "MaxDbl",
                typeof(double?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("MaxDbl", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<MaxDbl>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            maxDbl.TypeMapping = MySqlDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                keyComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                providerValueComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)));
            maxDbl.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            maxDbl.AddAnnotation("Relational:ColumnName", "max_Dbl");

            var message = runtimeEntityType.AddProperty(
                "Message",
                typeof(string),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Message", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Message>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            message.TypeMapping = MySqlStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "text"),
                storeTypePostfix: StoreTypePostfix.None);
            message.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            message.AddAnnotation("Relational:ColumnName", "message");
            message.AddAnnotation("Relational:ColumnType", "text");

            var min = runtimeEntityType.AddProperty(
                "Min",
                typeof(int?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Min", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Min>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            min.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            min.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            min.AddAnnotation("Relational:ColumnName", "min");

            var min64 = runtimeEntityType.AddProperty(
                "Min64",
                typeof(long?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Min64", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Min64>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            min64.TypeMapping = MySqlLongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                keyComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)),
                providerValueComparer: new ValueComparer<long?>(
                    (Nullable<long> v1, Nullable<long> v2) => v1.HasValue && v2.HasValue && (long)v1 == (long)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<long> v) => v.HasValue ? ((long)v).GetHashCode() : 0,
                    (Nullable<long> v) => v.HasValue ? (Nullable<long>)(long)v : default(Nullable<long>)));
            min64.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            min64.AddAnnotation("Relational:ColumnName", "min_64");

            var minDbl = runtimeEntityType.AddProperty(
                "MinDbl",
                typeof(double?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("MinDbl", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<MinDbl>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            minDbl.TypeMapping = MySqlDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                keyComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                providerValueComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)));
            minDbl.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            minDbl.AddAnnotation("Relational:ColumnName", "min_Dbl");

            var motion = runtimeEntityType.AddProperty(
                "Motion",
                typeof(uint?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Motion", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Motion>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            motion.TypeMapping = MySqlUIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                keyComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                providerValueComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)));
            motion.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            motion.AddAnnotation("Relational:ColumnName", "motion");

            var objCellId = runtimeEntityType.AddProperty(
                "ObjCellId",
                typeof(uint?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("ObjCellId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<ObjCellId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            objCellId.TypeMapping = MySqlUIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                keyComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                providerValueComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)));
            objCellId.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            objCellId.AddAnnotation("Relational:ColumnName", "obj_Cell_Id");

            var order = runtimeEntityType.AddProperty(
                "Order",
                typeof(uint),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Order", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Order>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0u);
            order.TypeMapping = MySqlUIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                providerValueComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v));
            order.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            order.AddAnnotation("Relational:ColumnName", "order");

            var originX = runtimeEntityType.AddProperty(
                "OriginX",
                typeof(float?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("OriginX", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<OriginX>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            originX.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            originX.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            originX.AddAnnotation("Relational:ColumnName", "origin_X");

            var originY = runtimeEntityType.AddProperty(
                "OriginY",
                typeof(float?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("OriginY", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<OriginY>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            originY.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            originY.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            originY.AddAnnotation("Relational:ColumnName", "origin_Y");

            var originZ = runtimeEntityType.AddProperty(
                "OriginZ",
                typeof(float?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("OriginZ", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<OriginZ>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            originZ.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            originZ.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            originZ.AddAnnotation("Relational:ColumnName", "origin_Z");

            var pScript = runtimeEntityType.AddProperty(
                "PScript",
                typeof(int?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("PScript", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<PScript>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            pScript.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            pScript.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            pScript.AddAnnotation("Relational:ColumnName", "p_Script");

            var palette = runtimeEntityType.AddProperty(
                "Palette",
                typeof(int?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Palette", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Palette>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            palette.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            palette.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            palette.AddAnnotation("Relational:ColumnName", "palette");

            var percent = runtimeEntityType.AddProperty(
                "Percent",
                typeof(double?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Percent", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Percent>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            percent.TypeMapping = MySqlDoubleTypeMapping.Default.Clone(
                comparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                keyComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)),
                providerValueComparer: new ValueComparer<double?>(
                    (Nullable<double> v1, Nullable<double> v2) => v1.HasValue && v2.HasValue && ((double)v1).Equals((double)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<double> v) => v.HasValue ? ((double)v).GetHashCode() : 0,
                    (Nullable<double> v) => v.HasValue ? (Nullable<double>)(double)v : default(Nullable<double>)));
            percent.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            percent.AddAnnotation("Relational:ColumnName", "percent");

            var shade = runtimeEntityType.AddProperty(
                "Shade",
                typeof(float?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Shade", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Shade>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            shade.TypeMapping = MySqlFloatTypeMapping.Default.Clone(
                comparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                keyComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)),
                providerValueComparer: new ValueComparer<float?>(
                    (Nullable<float> v1, Nullable<float> v2) => v1.HasValue && v2.HasValue && ((float)v1).Equals((float)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<float> v) => v.HasValue ? ((float)v).GetHashCode() : 0,
                    (Nullable<float> v) => v.HasValue ? (Nullable<float>)(float)v : default(Nullable<float>)));
            shade.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            shade.AddAnnotation("Relational:ColumnName", "shade");

            var sound = runtimeEntityType.AddProperty(
                "Sound",
                typeof(int?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Sound", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Sound>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            sound.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            sound.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            sound.AddAnnotation("Relational:ColumnName", "sound");

            var spellId = runtimeEntityType.AddProperty(
                "SpellId",
                typeof(int?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("SpellId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<SpellId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            spellId.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            spellId.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            spellId.AddAnnotation("Relational:ColumnName", "spell_Id");

            var stackSize = runtimeEntityType.AddProperty(
                "StackSize",
                typeof(int?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("StackSize", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<StackSize>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            stackSize.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            stackSize.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            stackSize.AddAnnotation("Relational:ColumnName", "stack_Size");

            var stat = runtimeEntityType.AddProperty(
                "Stat",
                typeof(int?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Stat", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Stat>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            stat.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            stat.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            stat.AddAnnotation("Relational:ColumnName", "stat");

            var testString = runtimeEntityType.AddProperty(
                "TestString",
                typeof(string),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("TestString", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<TestString>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            testString.TypeMapping = MySqlStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "text"),
                storeTypePostfix: StoreTypePostfix.None);
            testString.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            testString.AddAnnotation("Relational:ColumnName", "test_String");
            testString.AddAnnotation("Relational:ColumnType", "text");

            var treasureClass = runtimeEntityType.AddProperty(
                "TreasureClass",
                typeof(int?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("TreasureClass", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<TreasureClass>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            treasureClass.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            treasureClass.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            treasureClass.AddAnnotation("Relational:ColumnName", "treasure_Class");

            var treasureType = runtimeEntityType.AddProperty(
                "TreasureType",
                typeof(int?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("TreasureType", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<TreasureType>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            treasureType.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            treasureType.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            treasureType.AddAnnotation("Relational:ColumnName", "treasure_Type");

            var tryToBond = runtimeEntityType.AddProperty(
                "TryToBond",
                typeof(bool?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("TryToBond", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<TryToBond>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            tryToBond.TypeMapping = MySqlBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                keyComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                providerValueComparer: new ValueComparer<bool?>(
                    (Nullable<bool> v1, Nullable<bool> v2) => v1.HasValue && v2.HasValue && (bool)v1 == (bool)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<bool> v) => v.HasValue ? ((bool)v).GetHashCode() : 0,
                    (Nullable<bool> v) => v.HasValue ? (Nullable<bool>)(bool)v : default(Nullable<bool>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "bit(1)"));
            tryToBond.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            tryToBond.AddAnnotation("Relational:ColumnName", "try_To_Bond");

            var type = runtimeEntityType.AddProperty(
                "Type",
                typeof(uint),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Type", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Type>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0u);
            type.TypeMapping = MySqlUIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v),
                providerValueComparer: new ValueComparer<uint>(
                    (uint v1, uint v2) => v1 == v2,
                    (uint v) => (int)v,
                    (uint v) => v));
            type.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            type.AddAnnotation("Relational:ColumnName", "type");

            var wealthRating = runtimeEntityType.AddProperty(
                "WealthRating",
                typeof(int?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("WealthRating", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<WealthRating>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            wealthRating.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            wealthRating.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            wealthRating.AddAnnotation("Relational:ColumnName", "wealth_Rating");

            var weenieClassId = runtimeEntityType.AddProperty(
                "WeenieClassId",
                typeof(uint?),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("WeenieClassId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<WeenieClassId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            weenieClassId.TypeMapping = MySqlUIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                keyComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)),
                providerValueComparer: new ValueComparer<uint?>(
                    (Nullable<uint> v1, Nullable<uint> v2) => v1.HasValue && v2.HasValue && (uint)v1 == (uint)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<uint> v) => v.HasValue ? (int)(uint)v : 0,
                    (Nullable<uint> v) => v.HasValue ? (Nullable<uint>)(uint)v : default(Nullable<uint>)));
            weenieClassId.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            weenieClassId.AddAnnotation("Relational:ColumnName", "weenie_Class_Id");

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            var emoteid_order_uidx = runtimeEntityType.AddIndex(
                new[] { emoteId, order },
                name: "emoteid_order_uidx",
                unique: true);

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("EmoteId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id") }),
                principalEntityType,
                deleteBehavior: DeleteBehavior.Cascade,
                required: true);

            var emote = declaringEntityType.AddNavigation("Emote",
                runtimeForeignKey,
                onDependent: true,
                typeof(WeeniePropertiesEmote),
                propertyInfo: typeof(WeeniePropertiesEmoteAction).GetProperty("Emote", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmoteAction).GetField("<Emote>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            var weeniePropertiesEmoteAction = principalEntityType.AddNavigation("WeeniePropertiesEmoteAction",
                runtimeForeignKey,
                onDependent: false,
                typeof(ICollection<WeeniePropertiesEmoteAction>),
                propertyInfo: typeof(WeeniePropertiesEmote).GetProperty("WeeniePropertiesEmoteAction", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(WeeniePropertiesEmote).GetField("<WeeniePropertiesEmoteAction>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            runtimeForeignKey.AddAnnotation("Relational:Name", "emoteid_emoteaction");
            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "weenie_properties_emote_action");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
